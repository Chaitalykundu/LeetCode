class Solution {
public:
    int shortestSubarray(vector<int>& nums, int k) {
        int answer = INT_MAX; // Initialize answer with maximum possible value...
        long long curr_sum = 0; // To store the cumulative sum...
        deque<pair<long long, int>> dq; // A deque to store pairs of (prefix sum, index)...

        // Loop through the array...
        for (int idx = 0; idx < nums.size(); ++idx) {
            curr_sum += nums[idx]; // Update the cumulative sum...

            // Check if the current cumulative sum is already >= k...
            if (curr_sum >= k) {
                answer = min(answer, idx + 1); // Update the result with the current length...
            }

            // Remove elements from the front of the deque while the difference...
            // between the current cumulative sum and the prefix sum of the deque front is >= k...
            while (!dq.empty() && curr_sum - dq.front().first >= k) {
                answer = min(answer, idx - dq.front().second); // Update the result...
                dq.pop_front(); // Remove the front element...
            }

            // Remove elements from the back of the deque if they have a larger...
            // prefix sum than the current cumulative sum...
            while (!dq.empty() && dq.back().first > curr_sum) {
                dq.pop_back();
            }

            // Add the current cumulative sum and its index to the deque...
            dq.emplace_back(curr_sum, idx);
        }

        // If no valid subarray is found, return -1; otherwise, return the result...
        return (answer == INT_MAX) ? -1 : answer; // Time complexity : O(n) && Space Complexity : O(n)
    }
};
